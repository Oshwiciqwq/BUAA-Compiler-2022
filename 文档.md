# 编译器设计文档

## 一、参考编译器介绍

总结所阅读的编译器的总体结构、接口设计、文件组织等内容

## 二、编译器总体设计

介绍自己的将要实现的编译器的总体结构、接口设计、文件组织等内容

编译器使用 C++ 完成，只有一个文件 `main.cpp`。里面用若干个 namespace 来区分每个部分。

## 三、词法分析设计

编码前的设计、编码完成之后的修改

### 编码前的设计

大概思路是，把整个文件读进来，先去掉所有注释，再开始词法分析。词法分析的过程中模拟有限状态自动机，识别所有符号、关键字和标识符。

#### 读入

使用 `getline` 函数每次读取一行。`getline` 会读到换行位置，但读入的串结尾没有换行，为了判断方便手动加了一个 `\n`。

在读入的同时使用 string 的 find 函数，找到 `//` 或 `/*`，他们中最前面的那个会生效，然后忽略后面一段字符串，分别是到换行为止和到 `*/` 为止，找到对应位置直接删去。

把删掉的字符串拼在一起，组成完整的一份没有注释的代码。

#### 符号识别

通过模拟 DFA 来完成。由于题目中的符号类别并不太多，可以比较直观地看出一些特点。

- 以数字开头，一定是数字串。一串全部读进来。
- 以下划线或字符开头，可能是标识符，也可能是保留字，把一串全部读进来之后挨个比较是否是保留字，如果都不是，就是标识符。
- 出现一个引号 `"`，表明是 FormatString 的开始，读到下一个 `"` 结束。
- 其它各种符号，挨个判断。有些符号有两个字符，需要多读一个来分辨。如 `<` 和 `<=`，`!` 和 `!=` 等。

#### 符号的存储

我使用了一个 enum class，里面存着所有符号的类别码。即：

```c++
enum class Category {
    IDENFR, INTCON, STRCON, MAINTK, CONSTTK, INTTK, BREAKTK, CONTINUETK, IFTK, ELSETK,
    NOT, AND, OR, WHILETK, GETINTTK, PRINTFTK, RETURNTK, PLUS, MINU, VOIDTK,
    MULT, DIV, MOD, LSS, LEQ, GRE, GEQ, EQL, NEQ,
    ASSIGN, SEMICN, COMMA, LPARENT, RPARENT, LBRACK, RBRACK, LBRACE, RBRACE
};
```

然后一个符号用 `pair<Category, string>` 来表示，便于存储。

enum 并不能直接输出，不过 enum 里每个值实际上对应一个数字，并且在默认情况下是从 0 开始递增的。我又存了一个常量字符串数组，里面是类别码的字符串形式。最后直接输出数字对应的字符串即可。

```c++
const string CategoryToString[] = {
    "IDENFR", "INTCON", "STRCON", "MAINTK", "CONSTTK", "INTTK", "BREAKTK", "CONTINUETK", "IFTK", "ELSETK",
    "NOT", "AND", "OR", "WHILETK", "GETINTTK", "PRINTFTK", "RETURNTK", "PLUS", "MINU", "VOIDTK",
    "MULT", "DIV", "MOD", "LSS", "LEQ", "GRE", "GEQ", "EQL", "NEQ",
    "ASSIGN", "SEMICN", "COMMA", "LPARENT", "RPARENT", "LBRACK", "RBRACK", "LBRACE", "RBRACE"
};

//输出， i.first 即为 Category
for (auto &i: words) {
    output << CategoryToString[(int) i.first] << " " << i.second << endl;
}
```

### 编码完成之后的修改

在编码的时候我注意到可能会出现注释符号在引号内的情况，如 `"a//b"`、`"c*/d/*e"`等。查阅标准文档时我发现这种情况其实是 Undefined Behavior，不过我在测试用例库中找到了这样的例子，发现这种情况确实不被视为注释。因此之前的设计会比较麻烦，还需要判断注释是否在引号内。

所以我进行了修改，把注释的判断放到了 DFA 中。碰到 `/` 时，继续读一个字符，如果是 `/` 或 `*`，就说明是一段注释，进入对应子程序，读入字符直到结束。而如果都不是，就是普通的 DIV 符号。

现在读入也在符号识别的同时进行了。具体来说，每次读一行字符串，存一个当前遍历到的位置 `pos`。`getChar()` 函数表示得到下一个字符，与此同时把 `pos++`。如果遍历完了当前一行，就读新的一行。如果文件结束了返回一个 -1。

在符号识别的过程中，每次只需要调用 `getChar()` 函数即可。

这样总共也只遍历了一遍字符串，比之前的设计要好一点。



在错误处理的时候加入了行号。

## 四、语法分析设计

### 编码前的设计

主要是在词法分析的基础上，采用递归下降的方法来分析语法。为了方便以后的处理，建立了语法树。

语法树的每个结点记录当前是什么语法成分，以及儿子的邻接表。如果需要记录信息，如标识符字符串，就在 `ident` 数组里记录一个字符串。

#### 左递归问题

文法当中有一些规则会产生左递归的问题，需要进行修改来解决。

比如 `MulExp → UnaryExp | MulExp ('*' | '/' | '%') UnaryExp` 的规则，可以改写成 `MulExp → UnaryExp {('*' | '/' | '%') UnaryExp}`。

对这个规则进行分析的时候，只需要先递归找到一个 `UnaryExp`，此后只要有 `'*', '/', '%'` 中的任意一种就可以继续读下一个 `UnaryExp`，直到读完为止。

不过需要注意的是，这样建立的语法树并不符合原来的规则，在输出的时候应该要从第二个 `UnaryExp` 开始，每个 `UnaryExp` 后都加上一个 `MulExp`。

#### 回溯问题

为了避免回溯问题，需要进行预读来确定要如何递归下去。

比如 `Stmt` 有很多可能。首先可以判断 `if, while, break` 等保留字，然后还剩下 `LVal '=' Exp ';' | [Exp] ';' | LVal '=' 'getint''('')'';'` 三种情况。

`Exp` 的成分也很复杂，不过可以确定的是里面没有 `=`，所以可以不断预读，直到找到 `=` 或者 `;`，此时就可以判断是否为 `[Exp] ';'`。然后，再预读一位，就可以判断是不是 `getint`。

为了实现预读的操作，还需要实现配套的撤回操作。每次预读完都需要把当前的指针回退到开始的地方，否则无法继续递归下去。

#### 输出

我选择在递归下降的同时实现输出。

每次读一个词的时候，就把上一个词放进输出，因为当前词还没有确定在哪个短语里，所以还不能放。

然后，每个语法成分递归完了之后就可以输出这个语法成分（相当于是语法树的子树遍历完了，当前是一个短语）。全部存到一个输出的 `vector` 里，最后依次输出即可。

对于回溯问题，预读操作也会把词放到输出里，但是回撤的时候应该拿出来。可以使用 `vector` 的 `pop_back` 函数来方便地实现。

### 编码完成之后的修改

我发现 `Stmt` 有很多分支，如果全部放在 `Stmt` 里会比较难分辨是哪种类型，可能会对后面的处理造成困难。所以我把 `Stmt` 分成了很多类，相当于加了一些规则，比如：

`Stmt → IfStmt | WhileStmt | ... `，把这些看做 `Stmt` 在语法树上的儿子，只是不用输出而已。

此外，还有各种操作符，文法当中只有 `UnaryOp` 自成一类，其他的操作符直接看做 $V_t$ 了。为了以后方便，我把其它操作符全部当成 `Op` 类，在 `Op` 结点上记录是什么操作符。这样所有表达式的结构都是一样的了（子表达式和操作符交错）。

## 五、错误处理设计

### 编码前的设计

#### 添加行号

首先进行一波重构。之前的词法分析和语法分析完全没有考虑行号这个问题。而错误处理需要输出行号。

我在词法分析的时候维护当前行号，对每个词都存下它出现的行号。每次 `getline()` 会使得行号 +1。

在语法树中也要存储每个点对应的行号，以便于输出错误。但是每个错误需要报的行号对应的单词可能不同，需要对每个语法成分可能的错误考虑。大多数只需记录 ident 的行号即可。

#### 和语法分析的关系

有些错误会直接导致语法分析无法运行，比如 i,j,k 三种错误，这些必须在语法分析里判断。而如果把所有错误都在语法分析的同时处理会导致耦合度太高而且语法分析过于臃肿。

因此我选择把其中一些简单的错误在语法分析里处理，比如 a,i,j,k,l 等，其他则在语法分析结束后遍历语法树，需要通过维护符号表来实现。这一部分可能要和之后的代码生成一起做。

#### 缺少括号的情况

在 j 错误里，缺少括号会导致不知道是否接着分析 `Exp` 等成分。此时仍然可以根据 FIRST 集合尝试往下分析，但是就会使得函数里的参数个数变多等，产生别的错误。而题目中保证一行只有一个错误，在少括号之后不会出现少分号的情况，比较方便判断。

我的做法是直接往下分析，此后函数调用如果参数不对也视为错误，但是错误处理中只记录每一行第一次加入的错误。

#### 符号表

使用栈来维护符号表。

符号表中每个位置记录标识符、是否是函数，是否是常量，作用域，（数组）维度，（函数）每个参数的维度。

每次找的时候就从栈顶往下找到第一个标识符相同的。

对于作用域，我用 `Block` 的结点编号来代表这个 `Block` 的作用域，每个 `Block` 结束后把这个作用域定义的所有变量全部弹出栈。

### 编码完成之后的修改

实现过程中我发现比较难以判断调用函数的时候是几维数组。

此外，语法分析当中的 `Stmt` 部分判断在有错误的时候会有问题。

## 六、代码生成设计

编码前的设计、编码完成之后的修改
## 七、代码优化设计

编码前的设计、编码完成之后的修改，未选择MIPS代码生成的同学无需完成此项内容